/**
 * studiojs v0.0.1 By joeyguo
 * HomePage: https://github.com/joeyguo/studiojs
 * MIT Licensed.
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.studiojs = factory());
}(this, (function () { 'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Event = function () {
    function Event() {
        classCallCheck(this, Event);

        this.listeners = [];
    }

    createClass(Event, [{
        key: "trigger",
        value: function trigger(type) {
            for (var _len = arguments.length, opt = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                opt[_key - 1] = arguments[_key];
            }

            return this.listeners.filter(function (l) {
                var isMatch = type === l.type ? 1 : 0;
                isMatch && l.callback.apply(l, opt);
                return isMatch;
            }).reduce(function (a, b) {
                return a + b;
            }, 0);
        }
    }, {
        key: "on",
        value: function on(type, callback) {
            this.listeners.push({
                type: type,
                callback: callback
            });
            return this;
        }
    }]);
    return Event;
}();

var eventMap = {
    onClear: "clear",
    onReady: "ready",
    onStart: "start",
    onFrame: "frame",
    onEnd: "end"
};

for (var i in eventMap) {
    Event.prototype[i] = function (i) {
        return function (callback) {
            this.on(eventMap[i], callback);
            return this;
        };
    }(i);
}

var Stage = function (_Event) {
    inherits(Stage, _Event);

    function Stage(canvas) {
        classCallCheck(this, Stage);

        var _this = possibleConstructorReturn(this, (Stage.__proto__ || Object.getPrototypeOf(Stage)).call(this));

        _this.canvas = canvas;
        _this.ctx = _this.canvas.getContext('2d');
        _this.tracks = [];
        return _this;
    }

    createClass(Stage, [{
        key: 'add',
        value: function add(track) {
            var _this2 = this;

            var tracks = Object.prototype.toString.call(track) === "[object Array]" ? track : [track];
            tracks.map(function (item) {
                var canvas = document.createElement('canvas');
                canvas.width = _this2.canvas.width;
                canvas.height = _this2.canvas.height;
                canvas.ctx = canvas.getContext('2d');

                item.canvas = canvas;
                item.stage = _this2;
                _this2.tracks.push(item);
            });
        }
    }, {
        key: 'draw',
        value: function draw(type, isIgnoreFps) {
            var tracks = this.tracks;

            for (var i = 0, tracksUpdated = [], len = tracks.length; i < len; i++) {
                // 是否暂停
                if (tracks[i].isEnable) {

                    var newTrack = null;

                    // 无调用 draw 则返回 0，有 draw 则返回新 track
                    if (type === "next") {
                        newTrack = tracks[i].update(isIgnoreFps);
                    } else if (type === "prev") {
                        newTrack = tracks[i].prev(isIgnoreFps);
                    } else {
                        // draw 制定帧 type为数字
                        newTrack = tracks[i].to(type);
                    }

                    if (newTrack) {
                        tracksUpdated.push(newTrack);
                    }
                }
            }

            if (tracksUpdated.length > 0) {
                this.isEnd = false;
                tracksUpdated = tracksUpdated.sort(function (a, b) {
                    return a.zIndex - b.zIndex > 0;
                });
                // 清空 stage 画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                for (var j = 0; j < tracksUpdated.length; j++) {
                    this.ctx.drawImage(tracksUpdated[j].canvas, 0, 0);
                }
                this.trigger("frame");
            } else {
                // TODO 无任何draw时触发 加入空白元素时，应区分开
                this.trigger("end");
                this.isEnd = true;
            }
        }
    }, {
        key: 'update',
        value: function update(isIgnoreFps) {
            this.draw("next", isIgnoreFps);
        }
    }, {
        key: 'prev',
        value: function prev(isIgnoreFps) {
            this.draw("prev", isIgnoreFps);
        }
    }, {
        key: 'get',
        value: function get(type) {
            var tracks = this.tracks;
            for (var i = 0, _i = 0, len = tracks.length; i < len; i++) {
                if (type === "curIndex") {
                    _i = tracks[i].getCurIndex();
                } else if (type === "fLen") {
                    _i = tracks[i].getLen("frames");
                } else if (type === "mLen") {
                    _i = tracks[i].getLen("materials");
                }
                _i = i > _i ? i : _i;
            }
            return _i;
        }
    }, {
        key: 'getCurIndex',
        value: function getCurIndex() {
            return this.get("curIndex");
        }
    }, {
        key: 'getLen',
        value: function getLen(type) {
            return type === "frames" ? this.get("fLen") : type === "materials" ? this.get("mLen") : 0;
        }
    }]);
    return Stage;
}(Event);

var Material = function (_Event) {
    inherits(Material, _Event);

    function Material(track, id, material) {
        classCallCheck(this, Material);

        var _this = possibleConstructorReturn(this, (Material.__proto__ || Object.getPrototypeOf(Material)).call(this));

        _this.id = id;
        _this.track = track;
        _this.actIndex = -1;
        _this.material = material || {};
        _this.fps = _this.material.fps || 60;

        _this.animations = Material.formateAni(_this.material.animations || []);
        _this.animationsOrigin = Material.formateAniObj(_this.material.animationsOrigin || {});

        _this.times = 0;
        return _this;
    }

    createClass(Material, [{
        key: "clear",
        value: function clear(type, callback) {
            this.trigger("clear", this);
            this.animations = []; // 制空则跳过
            return this;
        }
    }], [{
        key: "formateAni",
        value: function formateAni(anis) {
            var res = [],
                arr,
                start,
                end;
            for (var i = 0; i < anis.length; i++) {
                arr = String(anis[i]).split("-"), start = arr[0], end = arr[1] === undefined ? arr[0] : arr[1];

                if (isNaN(start)) {
                    res.push(start);
                } else {
                    for (var j = Number(start); j <= Number(end); j++) {
                        res.push(j);
                    }
                }
            }
            return res;
        }
    }, {
        key: "formateAniObj",
        value: function formateAniObj(obj) {
            var res = {};
            for (var key in obj) {
                res[key] = Material.formateAni(obj[key]);
            }
            return res;
        }
    }]);
    return Material;
}(Event);

var Track = function () {
    function Track(zIndex) {
        classCallCheck(this, Track);

        this._id = 0;
        this.isEnable = true;

        this.zIndex = zIndex || 0;
        this.materials = [];
        this.curM = null;
    }

    // index 基于未播放的内容队列


    createClass(Track, [{
        key: "add",
        value: function add(material, index) {
            var m = new Material(this, this._id++, material);
            var i = index !== undefined ? this.getMIndex(this.curM) + index + 1 : this.materials.length;

            this.materials.splice(i, 0, m);
            return m;
        }
    }, {
        key: "update",
        value: function update(isIgnoreFps) {
            var curM = this.curM = this.curM || this.materials[0];
            if (!curM || !(curM.material && curM.material.isReady)) {
                return;
            }

            if (!isIgnoreFps) {
                ++curM.times;

                if (curM.times < 60 / curM.fps) {
                    return this;
                } else {
                    curM.times = 0;
                }
            }
            var actIndex = ++curM.actIndex;

            if (actIndex > curM.animations.length - 1) {

                var next = this.getNext();
                // console.log("next", this.curM, next)

                if (next && next.material.isReady) {
                    this.curM = next;
                    this.curM.actIndex = 0;

                    return this.draw(this.curM);
                } else {
                    // 到达最后 || 保留 下一个未 ready, 默认会清除
                    --curM.actIndex;
                    return;
                }
            }

            return this.draw(this.curM);
        }
    }, {
        key: "prev",
        value: function prev(isIgnoreFps) {
            // 拿到当前 frameAnimation 的当前帧
            var curM = this.curM = this.curM || this.materials[0];
            if (!curM || !(curM.material && curM.material.isReady)) {
                return;
            }

            if (!isIgnoreFps) {
                ++curM.times;

                if (curM.times < 60 / curM.fps) {
                    return this;
                } else {
                    curM.times = 0;
                }
            }

            var actIndex = --curM.actIndex;

            // 到最后了，判断下一个应该播放哪个 FrameAnimation
            if (actIndex < 0) {
                var prev = this.getPrev();

                if (prev && prev.material.isReady) {
                    this.curM = prev;
                    this.curM.actIndex = this.curM.animations.length - 1;
                    return this.draw(this.curM);
                } else {
                    ++curM.actIndex;
                    return;
                }
            }

            return this.draw(this.curM);
        }
    }, {
        key: "to",
        value: function to(index) {
            var _index = 0;
            for (var i = 0, materials = this.materials, material, len = materials.length; i < len; i++) {
                material = materials[i];
                var l = material.animations.length;
                _index += l;

                if (index <= _index - 1) {
                    this.curM = material;
                    this.curM.actIndex = index - (_index - l);
                }
            }

            return this.draw(this.curM);
        }
    }, {
        key: "draw",
        value: function draw(m, i) {
            var curM = m;
            var actIndex = i !== undefined ? i : curM.actIndex;

            var animations = curM.animations;
            var animation = animations[actIndex];

            if (isNaN(animation)) {
                var arr = curM.animationsOrigin[animation];
                // console.log(animation, arr)
                arr && animations.splice.apply(animations, [actIndex, 1].concat(toConsumableArray(arr)));
                animation = animations[actIndex];
            }

            if (animation === undefined) {
                return;
            }

            var curMM = curM.material;
            if (actIndex === 0) {
                curM.trigger("start", curM) || curMM.trigger("start", curM);
            } else if (actIndex === curM.animations.length - 1) {
                curM.trigger("end", curM) || curMM.trigger("end", curM);
            } else {
                curM.trigger("frame", actIndex, curM) || curMM.trigger("frame", curM);
            }

            var obj = curMM.sources[animation];
            var source = obj.source,
                loc = obj.loc;

            this.canvas._rect = {
                x: curM.x || 0,
                y: curM.y || 0,
                width: obj.width * (curM.scale || 1),
                height: obj.height * (curM.scale || 1)
            };

            this.canvas.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            if (curM.flip === "horizintal") {
                this.canvas._rect.x = this.canvas.width - (curM.x || 0) - obj.width * (curM.scale || 1);

                this.canvas.ctx.translate(this.canvas.width, 0);
                this.canvas.ctx.scale(-1, 1);
            }

            var _offX = (curM.x || 0) + (loc.offX || 0);
            var _offY = (curM.y || 0) + (loc.offY || 0);

            this.canvas.ctx.drawImage(source, loc.x || 0, loc.y || 0, obj.width, obj.height, _offX, _offY, obj.width * (curM.scale || 1), obj.height * (curM.scale || 1));
            // this.canvas.ctx.drawImage(source, loc.x, loc.y, obj.width, obj.height, (curM.x || 0), (curM.y || 0), (obj.width * (curM.scale || 1)), (obj.height * (curM.scale || 1)));

            if (curM.flip === "horizintal") {
                this.canvas.ctx.translate(this.canvas.width, 0);
                this.canvas.ctx.scale(-1, 1);
            }

            this.curM = curM;

            return this;
        }
    }, {
        key: "getMIndex",
        value: function getMIndex(m) {
            for (var i = 0, materials = this.materials, len = materials.length; i < len; i++) {
                if (materials[i].id == m.id) {
                    return i;
                }
            }
            return 0;
        }
    }, {
        key: "getPrev",
        value: function getPrev() {
            var _i = this.getMIndex(this.curM);
            return this.materials[_i - 1];
        }
    }, {
        key: "getNext",
        value: function getNext() {
            var _i = this.getMIndex(this.curM);
            return this.materials[_i + 1];
        }
    }, {
        key: "play",
        value: function play() {
            this.isEnable = true;
            this.stage.trigger("ready");
        }
    }, {
        key: "pause",
        value: function pause() {
            this.isEnable = false;
        }
    }, {
        key: "getLen",
        value: function getLen(type) {
            if (type === "frames") {
                return this.materials.reduce(function (a, b) {
                    return (a && a.animations.length || 0) + (b && b.animations.length || 0);
                }, 0);
            } else if (type === "materials") {
                return this.materials.length;
            }
        }
    }, {
        key: "getCurIndex",
        value: function getCurIndex(type) {
            var _index = 0;
            var materials = this.materials;
            for (var i = 0, len = materials.length; i < len; i++) {
                if (materials[i].id == this.curM.id) {
                    for (var j = 0; j < i; j++) {
                        var l = materials[i].animations.length;
                        _index += l;
                    }
                    // console.log(j, i, _index, materials[i].actIndex, _index += materials[i].actIndex)
                    return _index += materials[i].actIndex;
                }
            }
        }
    }]);
    return Track;
}();

function loadImage(images, callback, images_prefix) {
    for (var i = 0, len = images.length, img, n = 0, sources = []; i < len; i++) {
        (function (index) {
            var img = new Image();
            img.onload = function () {
                sources[index] = img;
                if (++n === len) {
                    callback && callback('complete', sources);
                }
            };
            img.src = images_prefix ? images_prefix + images[i] : images[i];
        })(i);
    }
}

function isArray(o) {
    return Object.prototype.toString.call(o) == '[object Array]';
}

var Frames = function (_Event) {
    inherits(Frames, _Event);

    function Frames(data, animations_type, fps) {
        classCallCheck(this, Frames);

        var _this = possibleConstructorReturn(this, (Frames.__proto__ || Object.getPrototypeOf(Frames)).call(this));

        _this.images_prefix = data.images_prefix;
        _this.images = data.images;

        _this.listeners = [];

        _this.animationsOrigin = data.animations;

        _this.animations = data['animations'] && data['animations'][animations_type] || ['0-' + (_this.images.length - 1)];

        _this.fps = fps;

        _this.frames = data.frames;

        if (typeof data.images[0] === "string") {
            loadImage(_this.images, function (type, sources) {
                if (type === 'complete') {
                    _this.sources = _this.formate(sources);
                    _this.isReady = true;
                }
            }, data.images_prefix);
        } else {
            _this.sources = _this.formate(data.images);
            _this.isReady = true;
        }

        return _this;
    }

    createClass(Frames, [{
        key: 'formate',
        value: function formate(sources) {
            var _sources = [],
                frames = this.frames;

            if (isArray(frames)) {
                // 合图，每帧宽高不一样

                for (var i = 0, _f; i < frames.length; i++) {
                    _f = frames[i];

                    if (isArray(_f)) {
                        _sources.push({
                            source: sources[_f[6] || 0],
                            loc: {
                                x: _f[0] || 0,
                                y: _f[1] || 0,
                                offX: _f[4] || 0,
                                offY: _f[5] || 0
                            },
                            width: _f[2],
                            height: _f[3]
                        });
                    } else {
                        _sources.push({
                            source: sources[_f.index || 0],
                            loc: {
                                x: _f.x || 0,
                                y: _f.y || 0,
                                offX: _f.offX || 0,
                                offY: _f.offY || 0
                            },
                            width: _f.width,
                            height: _f.height
                        });
                    }
                }
            } else {

                // 单图，或 设置 frame: {width: height:} 的元素大小一致的合图

                var f_w = frames && frames.width,
                    f_h = frames && frames.height;

                for (var i = 0, source; i < sources.length; i++) {
                    source = sources[i];

                    var s_w = source.width,
                        s_h = source.height;

                    var w = f_w ? f_w : s_w,
                        h = f_h ? f_h : s_h;

                    var xSize = s_w / w,
                        ySize = s_h / h;

                    for (var k = 0; k < ySize; k++) {
                        for (var j = 0; j < xSize; j++) {
                            _sources.push({
                                source: source,
                                loc: {
                                    x: j * w,
                                    y: k * h,
                                    offX: frames && frames.offX || 0,
                                    offY: frames && frames.offY || 0
                                },
                                width: w,
                                height: h
                            });
                        }
                    }
                }
            }

            return _sources;
        }
    }]);
    return Frames;
}(Event);

var index = {
    Stage: Stage,
    Track: Track,
    Frames: Frames,
    loadImage: loadImage
};

return index;

})));
