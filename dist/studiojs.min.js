/**
 * studiojs v0.0.1 By joeyguo
 * HomePage: https://github.com/joeyguo/studiojs
 * MIT Licensed.
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.studiojs = factory());
}(this, (function () { 'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Event = function () {
    function Event() {
        classCallCheck(this, Event);

        this.listeners = [];
    }

    createClass(Event, [{
        key: "trigger",
        value: function trigger(type) {
            for (var _len = arguments.length, opt = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                opt[_key - 1] = arguments[_key];
            }

            return this.listeners.filter(function (l) {
                var isMatch = type === l.type ? 1 : 0;
                isMatch && l.callback.apply(l, opt);
                return isMatch;
            }).reduce(function (a, b) {
                return a + b;
            }, 0);
        }
    }, {
        key: "on",
        value: function on(type, callback) {
            this.listeners.push({
                type: type,
                callback: callback
            });
            return this;
        }
    }]);
    return Event;
}();

var eventMap = {
    onClear: "clear",
    onReady: "ready",
    onStart: "start",
    onFrame: "frame",
    onEnd: "end"
};

for (var i in eventMap) {
    Event.prototype[i] = function (i) {
        return function (callback) {
            this.on(eventMap[i], callback);
            return this;
        };
    }(i);
}

function isArray(o) {
    return Object.prototype.toString.call(o) == '[object Array]';
}

function createCanvas(width, height) {
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;

    canvas.ctx = canvas.getContext('2d');
    return canvas;
}

function formateAni(anis) {

    var res = [],
        arr,
        start,
        end;

    for (var i = 0; i < anis.length; i++) {
        arr = String(anis[i]).split("-"), start = arr[0], end = arr[1] === undefined ? arr[0] : arr[1];

        if (isNaN(start)) {
            res.push(start);
        } else {
            for (var j = Number(start); j <= Number(end); j++) {
                res.push(j);
            }
        }
    }

    return res;
}

function formateAniObj(obj) {

    var res = {};

    for (var key in obj) {
        res[key] = formateAni(obj[key]);
    }

    return res;
}

var Stage = function (_Event) {
    inherits(Stage, _Event);

    function Stage(canvas) {
        classCallCheck(this, Stage);

        var _this = possibleConstructorReturn(this, (Stage.__proto__ || Object.getPrototypeOf(Stage)).call(this));

        _this.canvas = canvas;
        _this.ctx = _this.canvas.getContext('2d');
        _this.tracks = [];
        return _this;
    }

    createClass(Stage, [{
        key: 'add',
        value: function add(track) {
            var _this2 = this;

            var tracks = isArray(track) ? track : [track];
            tracks.map(function (item) {
                // 为 track 重置一个 canvas，不会具体画出来
                item.canvas = createCanvas(_this2.canvas.width, _this2.canvas.height);
                item.stage = _this2;
                _this2.tracks.push(item);
            });
        }
    }, {
        key: 'draw',
        value: function draw(type, isIgnoreFps) {
            var tracks = this.tracks;

            for (var i = 0, tracksUpdated = [], len = tracks.length; i < len; i++) {
                // 是否暂停
                if (tracks[i].isEnable) {

                    var newTrack = null;

                    // 无调用 draw 则返回 0，有 draw 则返回新 track
                    if (type === "next") {
                        newTrack = tracks[i].update(isIgnoreFps);
                    } else if (type === "prev") {
                        newTrack = tracks[i].prev(isIgnoreFps);
                    } else {
                        // draw 制定帧 type为数字
                        newTrack = tracks[i].to(type);
                    }

                    if (newTrack) {
                        tracksUpdated.push(newTrack);
                    }
                }
            }

            if (tracksUpdated.length > 0) {
                this.isEnd = false;
                tracksUpdated = tracksUpdated.sort(function (a, b) {
                    return a.zIndex - b.zIndex > 0;
                });
                // 清空 stage 画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                for (var j = 0; j < tracksUpdated.length; j++) {
                    this.ctx.drawImage(tracksUpdated[j].canvas, 0, 0);
                }
                this.trigger("frame");
            } else {
                // TODO 无任何draw时触发 加入空白元素时，应区分开
                this.trigger("end");
                this.isEnd = true;
            }
        }
    }, {
        key: 'update',
        value: function update(isIgnoreFps) {
            this.draw("next", isIgnoreFps);
        }
    }, {
        key: 'prev',
        value: function prev(isIgnoreFps) {
            this.draw("prev", isIgnoreFps);
        }
    }, {
        key: 'get',
        value: function get(type) {
            var tracks = this.tracks;
            for (var i = 0, _i = 0, len = tracks.length; i < len; i++) {
                if (type === "curIndex") {
                    _i = tracks[i].getCurIndex();
                } else if (type === "fLen") {
                    _i = tracks[i].getLen("frames");
                } else if (type === "mLen") {
                    _i = tracks[i].getLen("materials");
                }
                _i = i > _i ? i : _i;
            }
            return _i;
        }
    }, {
        key: 'getCurIndex',
        value: function getCurIndex() {
            return this.get("curIndex");
        }
    }, {
        key: 'getLen',
        value: function getLen(type) {
            return type === "frames" ? this.get("fLen") : type === "materials" ? this.get("mLen") : 0;
        }
    }]);
    return Stage;
}(Event);

var Track = function () {
    function Track(zIndex, canvas) {
        classCallCheck(this, Track);

        this._id = 0;
        this.zIndex = zIndex || 0;
        this.isEnable = true;
        this.materials = [];
        this.curM = null;

        if (canvas) {
            this.canvas = canvas;
            this.canvas.ctx = canvas.getContext('2d');
        }
    }

    // index 基于未播放的内容队列


    createClass(Track, [{
        key: 'add',
        value: function add(material, index) {

            material.id = this._id++;
            material.track = this;

            material.canvas = createCanvas(this.canvas.width, this.canvas.height);

            var i = index !== undefined ? this.getMIndex(this.curM) + index + 1 : this.materials.length;
            // console.log(i)
            this.materials.splice(i, 0, material);
            return material;
        }
    }, {
        key: 'update',
        value: function update(isIgnoreFps) {
            var curM = this.curM = this.curM || this.materials[0];

            if (!curM) {
                return;
            }
            if (curM.isEnd) {
                var next = this.getNext();
                if (next && next.isReady) {
                    this.curM = next;
                    this.curM.actIndex = -1;
                    return this.update(true);
                }
                return;
            }

            var m = curM.update(isIgnoreFps);
            return this.draw(m.canvas);
        }
    }, {
        key: 'prev',
        value: function prev(isIgnoreFps) {
            var curM = this.curM = this.curM || this.materials[0];

            if (curM.actIndex <= 0) {
                var prev = this.getPrev();
                if (prev && prev.isReady) {
                    this.curM = prev;
                    this.curM.actIndex = this.curM.animation.length - 1;
                    return this.prev();
                }
                return;
            }

            var m = curM.prev();

            return this.draw(m.canvas);
        }
    }, {
        key: 'draw',
        value: function draw(canvas) {
            this.canvas.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.canvas.ctx.drawImage(canvas, 0, 0);

            return this;
        }

        // to(index) {
        //     var _index = 0;
        //     for (var i = 0, materials = this.materials, material, len = materials.length; i < len; i++) {
        //         material = materials[i];
        //         var l = material.animation.length;
        //         _index += l;

        //         if (index <= _index - 1) {
        //             this.curM = material;
        //             this.curM.actIndex = index - (_index - l);
        //         }
        //     }

        //     return this.draw(this.curM);
        // }

    }, {
        key: 'getMIndex',
        value: function getMIndex(m) {
            for (var i = 0, materials = this.materials, len = materials.length; i < len; i++) {
                if (materials[i].id == m.id) {
                    return i;
                }
            }
            return 0;
        }
    }, {
        key: 'getPrev',
        value: function getPrev() {
            var _i = this.getMIndex(this.curM);
            return this.materials[_i - 1];
        }
    }, {
        key: 'getNext',
        value: function getNext() {
            var _i = this.getMIndex(this.curM);
            return this.materials[_i + 1];
        }
    }, {
        key: 'play',
        value: function play() {
            this.isEnable = true;
            this.stage.trigger("ready");
        }
    }, {
        key: 'pause',
        value: function pause() {
            this.isEnable = false;
        }
    }, {
        key: 'getLen',
        value: function getLen(type) {
            if (type === "frames") {
                return this.materials.reduce(function (a, b) {
                    return (a && a.animation.length || 0) + (b && b.animation.length || 0);
                }, 0);
            } else if (type === "materials") {
                return this.materials.length;
            }
        }
    }, {
        key: 'getCurIndex',
        value: function getCurIndex(type) {
            var _index = 0;
            var materials = this.materials;
            for (var i = 0, len = materials.length; i < len; i++) {
                if (materials[i].id == this.curM.id) {
                    for (var j = 0; j < i; j++) {
                        var l = materials[i].animation.length;
                        _index += l;
                    }
                    return _index += materials[i].actIndex;
                }
            }
        }
    }]);
    return Track;
}();

function loadImage(images, callback, images_prefix) {
    for (var i = 0, len = images.length, img, n = 0, sources = []; i < len; i++) {
        (function (index) {
            var img = new Image();
            img.onload = function () {
                sources[index] = img;
                if (++n === len) {
                    callback && callback('complete', sources);
                }
            };
            img.src = images_prefix ? images_prefix + images[i] : images[i];
        })(i);
    }
}

var Frames = function (_Event) {
    inherits(Frames, _Event);

    function Frames(data, type, fps, canvas) {
        classCallCheck(this, Frames);

        var _this = possibleConstructorReturn(this, (Frames.__proto__ || Object.getPrototypeOf(Frames)).call(this));

        var imgPrefix = data.imgPrefix,
            images = data.images,
            animations = data.animations,
            frames = data.frames;


        _this.animations = animations;
        _this.animation = animations && animations[type] || ['0-' + (images.length - 1)];
        _this.fps = fps;

        _this.animation = formateAni(_this.animation || []);
        _this.animations = formateAniObj(_this.animations || {});

        _this.listeners = [];
        _this.actIndex = -1;

        if (typeof images[0] === "string") {
            loadImage(images, function (type, sources) {
                if (type === 'complete') {
                    _this.sources = _this.formate(sources, frames);
                    _this.isReady = true;
                }
            }, imgPrefix);
        } else {
            _this.sources = _this.formate(images, frames);
            _this.isReady = true;
        }

        if (canvas) {
            _this.canvas = canvas;
            _this.canvas.ctx = canvas.getContext('2d');
        }

        _this.times = 0;
        return _this;
    }

    createClass(Frames, [{
        key: 'formate',
        value: function formate(images) {
            var frames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


            var sources = [];

            if (isArray(frames)) {

                for (var i = 0, f; i < frames.length; i++) {
                    f = frames[i];
                    sources.push({
                        source: images[f[6] || 0],
                        loc: {
                            x: f[0] || 0,
                            y: f[1] || 0,
                            offX: f[4] || 0,
                            offY: f[5] || 0
                        },
                        width: f[2],
                        height: f[3]
                    });
                }
            } else {

                // 单图，或 设置 frame: {width: height:} 的元素大小一致的合图

                var f_w = frames.width,
                    f_h = frames.height;

                for (var i = 0, s; i < images.length; i++) {
                    s = images[i];

                    var s_w = s.width,
                        s_h = s.height;

                    var w = f_w ? f_w : s_w,
                        h = f_h ? f_h : s_h;

                    var xSize = s_w / w,
                        ySize = s_h / h;

                    for (var k = 0; k < ySize; k++) {
                        for (var j = 0; j < xSize; j++) {
                            sources.push({
                                source: s,
                                loc: {
                                    x: j * w,
                                    y: k * h,
                                    offX: frames.offX || 0,
                                    offY: frames.offY || 0
                                },
                                width: w,
                                height: h
                            });
                        }
                    }
                }
            }

            return sources;
        }
    }, {
        key: 'update',
        value: function update(isIgnoreFps) {
            if (!this.isReady) {
                return;
            }

            if (!isIgnoreFps) {
                ++this.times;

                if (this.times < 60 / this.fps) {
                    return this;
                } else {
                    this.times = 0;
                }
            }

            // console.log(this.actIndex + 1)
            // console.log(this.actIndex + 1 > this.animation.length - 1)
            // 播完当前动画

            if (this.actIndex + 1 > this.animation.length - 1) {
                this.isEnd = true;
                return this;
            }

            ++this.actIndex;

            // console.log("p-----")
            // console.log(actIndex)
            // console.log(actIndex > this.animation.length - 1)
            // console.log(this.animation.length - 1)

            return this.draw(this);
        }
    }, {
        key: 'prev',
        value: function prev(isIgnoreFps) {
            if (!this.isReady) {
                return;
            }

            if (!isIgnoreFps) {
                ++this.times;

                if (this.times < 60 / this.fps) {
                    return this;
                } else {
                    this.times = 0;
                }
            }

            var actIndex = --this.actIndex;

            // 到最后
            if (actIndex < 0) {
                return this;
            }

            return this.draw(this);
        }
    }, {
        key: 'draw',
        value: function draw(m, i) {
            var curM = m;
            var actIndex = i !== undefined ? i : curM.actIndex;

            var animation = curM.animation;
            var acitveOne = animation[actIndex];

            if (isNaN(acitveOne)) {
                var arr = curM.animations[acitveOne];
                // console.log(acitveOne, curM.animations)
                // console.log(animation, arr)
                arr && animation.splice.apply(animation, [actIndex, 1].concat(toConsumableArray(arr)));
                acitveOne = animation[actIndex];
            }

            if (acitveOne === undefined) {
                return;
            }

            var curMM = m;

            // console.log("--------actIndex")
            // console.log(actIndex)
            // console.log(m.id)
            if (actIndex === 0) {
                // console.log("start")
                curM.trigger("start", curM);
            } else if (actIndex === curM.animation.length - 1) {
                // console.log("end")
                curM.trigger("end", curM);
            } else {
                // console.log("frame")
                curM.trigger("frame", actIndex, curM);
            }

            var obj = curMM.sources[acitveOne];
            var source = obj.source,
                loc = obj.loc;

            var ctx = this.canvas.ctx,
                canvas = this.canvas;

            canvas._rect = {
                x: curM.x || 0,
                y: curM.y || 0,
                width: obj.width * (curM.scale || 1),
                height: obj.height * (curM.scale || 1)
            };

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (curM.flip === "horizintal") {
                canvas._rect.x = canvas.width - (curM.x || 0) - obj.width * (curM.scale || 1);

                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
            }

            var _offX = (curM.x || 0) + (loc.offX || 0);
            var _offY = (curM.y || 0) + (loc.offY || 0);

            ctx.drawImage(source, loc.x || 0, loc.y || 0, obj.width, obj.height, _offX, _offY, obj.width * (curM.scale || 1), obj.height * (curM.scale || 1));
            // this.canvas.ctx.drawImage(source, loc.x, loc.y, obj.width, obj.height, (curM.x || 0), (curM.y || 0), (obj.width * (curM.scale || 1)), (obj.height * (curM.scale || 1)));

            if (curM.flip === "horizintal") {
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
            }

            this.curM = curM;

            return this;
        }
    }, {
        key: 'clear',
        value: function clear(type, callback) {
            this.trigger("clear", this);
            this.animation = []; // 制空则跳过
            return this;
        }
    }]);
    return Frames;
}(Event);

var index2 = {
    Stage: Stage,
    Track: Track,
    Frames: Frames,
    loadImage: loadImage
};

return index2;

})));
